/**
 * QuantiModo
 * QuantiModo makes it easy to retrieve normalized user data from a wide array of devices and applications. [Learn about QuantiModo](https://quantimo.do), check out our [docs](https://github.com/QuantiModo/docs) or contact us at [help.quantimo.do](https://help.quantimo.do). 
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH }                                         from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class TagsApi {
    protected basePath = 'https://app.quantimo.do/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }
	
	/**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * Delete user tag or ingredient
     * Delete previously created user tags or ingredients.
     * @param taggedVariableId This is the id of the variable being tagged with an ingredient or something.
     * @param tagVariableId This is the id of the ingredient variable whose value is determined based on the value of the tagged variable.
     */
    public v1UserTagsDeletePost(taggedVariableId: number, tagVariableId: number, extraHttpRequestParams?: any): Observable<models.CommonResponse> {
        return this.v1UserTagsDeletePostWithHttpInfo(taggedVariableId, tagVariableId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Post or update user tags or ingredients
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @param body Contains the new user tag data
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId User&#39;s id
     */
    public v1UserTagsPost(body: models.UserTag, accessToken?: string, userId?: number, extraHttpRequestParams?: any): Observable<models.CommonResponse> {
        return this.v1UserTagsPostWithHttpInfo(body, accessToken, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Delete user tag or ingredient
     * Delete previously created user tags or ingredients.
     * @param taggedVariableId This is the id of the variable being tagged with an ingredient or something.
     * @param tagVariableId This is the id of the ingredient variable whose value is determined based on the value of the tagged variable.
     */
    public v1UserTagsDeletePostWithHttpInfo(taggedVariableId: number, tagVariableId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v1/userTags/delete`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'taggedVariableId' is not null or undefined
        if (taggedVariableId === null || taggedVariableId === undefined) {
            throw new Error('Required parameter taggedVariableId was null or undefined when calling v1UserTagsDeletePost.');
        }
        // verify required parameter 'tagVariableId' is not null or undefined
        if (tagVariableId === null || tagVariableId === undefined) {
            throw new Error('Required parameter tagVariableId was null or undefined when calling v1UserTagsDeletePost.');
        }
        if (taggedVariableId !== undefined) {
            queryParameters.set('taggedVariableId', <any>taggedVariableId);
        }
        if (tagVariableId !== undefined) {
            queryParameters.set('tagVariableId', <any>tagVariableId);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];
        
        // authentication (access_token) required
        if (this.configuration.apiKey)
        {
            formParams.set('access_token', this.configuration.apiKey);
        }
        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Post or update user tags or ingredients
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @param body Contains the new user tag data
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId User&#39;s id
     */
    public v1UserTagsPostWithHttpInfo(body: models.UserTag, accessToken?: string, userId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/v1/userTags`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling v1UserTagsPost.');
        }
        if (accessToken !== undefined) {
            queryParameters.set('access_token', <any>accessToken);
        }
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];
        
        // authentication (access_token) required
        if (this.configuration.apiKey)
        {
            formParams.set('access_token', this.configuration.apiKey);
        }
        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken)
        {
            headers.set('Authorization', 'Bearer ' + this.configuration.accessToken);
        }
            

        headers.set('Content-Type', 'application/json');


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
