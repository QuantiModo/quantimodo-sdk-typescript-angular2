/**
 * quantimodo
 * QuantiModo makes it easy to retrieve normalized user data from a wide array of devices and applications. [Learn about QuantiModo](https://quantimo.do), check out our [docs](https://github.com/QuantiModo/docs) or contact us at [help.quantimo.do](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.728
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AnalyticsApi {

    protected basePath = 'https://app.quantimo.do/api';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Delete previously posted vote
     * @summary Delete vote
     * @param body The cause and effect variable names for the predictor vote to be deleted.
     * @param userId User&#39;s id
     */
    public deleteVote(body: models.VoteDelete, userId?: number, extraHttpRequestParams?: any): Observable<models.CommonResponse> {
        return this.deleteVoteWithHttpInfo(body, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Get correlations based on the anonymized aggregate data from all QuantiModo users.
     * @summary Get aggregated correlations
     * @param userId User&#39;s id
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param onsetDelay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param durationOfAction The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     */
    public getAggregatedCorrelations(userId?: number, effectVariableName?: string, causeVariableName?: string, correlationCoefficient?: string, onsetDelay?: string, durationOfAction?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, outcomesOfInterest?: boolean, extraHttpRequestParams?: any): Observable<Array<models.Correlations>> {
        return this.getAggregatedCorrelationsWithHttpInfo(userId, effectVariableName, causeVariableName, correlationCoefficient, onsetDelay, durationOfAction, updatedAt, limit, offset, sort, outcomesOfInterest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Get correlations based on data from a single user.
     * @summary Get correlations
     * @param userId User&#39;s id
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param onsetDelay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param durationOfAction The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     */
    public getCorrelations(userId?: number, effectVariableName?: string, causeVariableName?: string, correlationCoefficient?: string, onsetDelay?: string, durationOfAction?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, outcomesOfInterest?: boolean, extraHttpRequestParams?: any): Observable<Array<models.Correlation>> {
        return this.getCorrelationsWithHttpInfo(userId, effectVariableName, causeVariableName, correlationCoefficient, onsetDelay, durationOfAction, updatedAt, limit, offset, sort, outcomesOfInterest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Get explanations of  correlations based on data from a single user.
     * @summary Get correlation explanations
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     */
    public getUserCorrelationExplantions(effectVariableName?: string, causeVariableName?: string, extraHttpRequestParams?: any): Observable<Array<models.Correlation>> {
        return this.getUserCorrelationExplantionsWithHttpInfo(effectVariableName, causeVariableName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Add correlation
     * @summary Store or Update a Correlation
     * @param body Provides correlation data
     * @param userId User&#39;s id
     */
    public postAggregatedCorrelations(body: models.PostCorrelation, userId?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.postAggregatedCorrelationsWithHttpInfo(body, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * This is to enable users to indicate their opinion on the plausibility of a causal relationship between a treatment and outcome. QuantiModo incorporates crowd-sourced plausibility estimations into their algorithm. This is done allowing user to indicate their view of the plausibility of each relationship with thumbs up/down buttons placed next to each prediction.
     * @summary Post or update vote
     * @param body Contains the cause variable, effect variable, and vote value.
     * @param userId User&#39;s id
     */
    public postVote(body: models.Vote, userId?: number, extraHttpRequestParams?: any): Observable<models.CommonResponse> {
        return this.postVoteWithHttpInfo(body, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Delete vote
     * Delete previously posted vote
     * @param body The cause and effect variable names for the predictor vote to be deleted.
     * @param userId User&#39;s id
     */
    public deleteVoteWithHttpInfo(body: models.VoteDelete, userId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v3/votes/delete';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteVote.');
        }
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get aggregated correlations
     * Get correlations based on the anonymized aggregate data from all QuantiModo users.
     * @param userId User&#39;s id
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param onsetDelay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param durationOfAction The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     */
    public getAggregatedCorrelationsWithHttpInfo(userId?: number, effectVariableName?: string, causeVariableName?: string, correlationCoefficient?: string, onsetDelay?: string, durationOfAction?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, outcomesOfInterest?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v3/aggregatedCorrelations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }

        if (effectVariableName !== undefined) {
            queryParameters.set('effectVariableName', <any>effectVariableName);
        }

        if (causeVariableName !== undefined) {
            queryParameters.set('causeVariableName', <any>causeVariableName);
        }

        if (correlationCoefficient !== undefined) {
            queryParameters.set('correlationCoefficient', <any>correlationCoefficient);
        }

        if (onsetDelay !== undefined) {
            queryParameters.set('onsetDelay', <any>onsetDelay);
        }

        if (durationOfAction !== undefined) {
            queryParameters.set('durationOfAction', <any>durationOfAction);
        }

        if (updatedAt !== undefined) {
            queryParameters.set('updatedAt', <any>updatedAt);
        }

        if (limit !== undefined) {
            queryParameters.set('limit', <any>limit);
        }

        if (offset !== undefined) {
            queryParameters.set('offset', <any>offset);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (outcomesOfInterest !== undefined) {
            queryParameters.set('outcomesOfInterest', <any>outcomesOfInterest);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get correlations
     * Get correlations based on data from a single user.
     * @param userId User&#39;s id
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param onsetDelay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param durationOfAction The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 &#x60;YYYY-MM-DDThh:mm:ss&#x60; datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     */
    public getCorrelationsWithHttpInfo(userId?: number, effectVariableName?: string, causeVariableName?: string, correlationCoefficient?: string, onsetDelay?: string, durationOfAction?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, outcomesOfInterest?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v4/correlations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }

        if (effectVariableName !== undefined) {
            queryParameters.set('effectVariableName', <any>effectVariableName);
        }

        if (causeVariableName !== undefined) {
            queryParameters.set('causeVariableName', <any>causeVariableName);
        }

        if (correlationCoefficient !== undefined) {
            queryParameters.set('correlationCoefficient', <any>correlationCoefficient);
        }

        if (onsetDelay !== undefined) {
            queryParameters.set('onsetDelay', <any>onsetDelay);
        }

        if (durationOfAction !== undefined) {
            queryParameters.set('durationOfAction', <any>durationOfAction);
        }

        if (updatedAt !== undefined) {
            queryParameters.set('updatedAt', <any>updatedAt);
        }

        if (limit !== undefined) {
            queryParameters.set('limit', <any>limit);
        }

        if (offset !== undefined) {
            queryParameters.set('offset', <any>offset);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (outcomesOfInterest !== undefined) {
            queryParameters.set('outcomesOfInterest', <any>outcomesOfInterest);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get correlation explanations
     * Get explanations of  correlations based on data from a single user.
     * @param effectVariableName Variable name of the hypothetical effect variable.  Example: Overall Mood
     * @param causeVariableName Variable name of the hypothetical cause variable.  Example: Sleep Duration
     */
    public getUserCorrelationExplantionsWithHttpInfo(effectVariableName?: string, causeVariableName?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v3/correlations/explanations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (effectVariableName !== undefined) {
            queryParameters.set('effectVariableName', <any>effectVariableName);
        }

        if (causeVariableName !== undefined) {
            queryParameters.set('causeVariableName', <any>causeVariableName);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Store or Update a Correlation
     * Add correlation
     * @param body Provides correlation data
     * @param userId User&#39;s id
     */
    public postAggregatedCorrelationsWithHttpInfo(body: models.PostCorrelation, userId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v3/aggregatedCorrelations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postAggregatedCorrelations.');
        }
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Post or update vote
     * This is to enable users to indicate their opinion on the plausibility of a causal relationship between a treatment and outcome. QuantiModo incorporates crowd-sourced plausibility estimations into their algorithm. This is done allowing user to indicate their view of the plausibility of each relationship with thumbs up/down buttons placed next to each prediction.
     * @param body Contains the cause variable, effect variable, and vote value.
     * @param userId User&#39;s id
     */
    public postVoteWithHttpInfo(body: models.Vote, userId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/v3/votes';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postVote.');
        }
        if (userId !== undefined) {
            queryParameters.set('userId', <any>userId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (access_token) required
        if (this.configuration.apiKey) {
            queryParameters.set('access_token', this.configuration.apiKey);
        }

        // authentication (quantimodo_oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
